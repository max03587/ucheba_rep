
### Инкапсуляция
**Инкапсуляция** — один из ключевых принципов объектно-ориентированного программирования (ООП). Она подразумевает **скрытие внутреннего состояния объекта** и предоставление доступа к этому состоянию **только через строго определённые методы**.

###### Принцип

- **Скрытие данных** (или сокрытие реализации). Внутреннее состояние объекта (его поля или атрибуты) обычно объявляется как приватное или защищённое, что предотвращает прямой доступ к нему из-за пределов объекта.
- **Использование методов доступа** (геттеры для получения значения, сеттеры для установки значения). Это позволяет контролировать доступ к данным и выполнять необходимые проверки или дополнительные действия при их изменении.
- **Повышение гибкости кода** — скрытие внутренней реализации позволяет изменять её без влияния на код, использующий объект.

###### Пример кода

``` python
#!/usr/bin/python3
class Phone:    
	number = "111-11-11"    
	def print_number(self):        
		print( "Phone number is: ", self.number )
		
my_phone = Phone()
my_phone.print_number()
input( "Press Enter to exit" )
```

В данном случае, любой класс в котором есть хотя бы одна переменная и один метод который ею управляет наглядно демонстрирует этот принцип.

### Наследование

**Наследование в объектно-ориентированном программировании (ООП) на Python** — это механизм, который позволяет создавать новый класс (наследник, дочерний класс) на основе уже существующего (родителя, базового класса). Дочерний класс автоматически получает все атрибуты и методы родителя, но может добавлять собственные или переопределять унаследованные.

######  Пример кода

``` python
class Vehicle: 
	def __init__(self, brand, year): 
		self.brand = brand 
		self.year = year 
	def display_info(self): 
		return f"Транспорт марки {self.brand}, год выпуска: {self.year}" 
	def start_engine(self): 
		return "Двигатель запущен" [1](https://sky.pro/wiki/python/oop-v-python-nasledovanie/) 

class Car(Vehicle): 
	def __init__(self, brand, year, model): 
		super().__init__(brand, year) 
		self.model = model  
def honk(self): 
	return "Бип-бип!"
```

В этом примере Car наследует от Vehicle, получая его атрибуты brand и year, а также методы display_info и start_engine. При этом класс Car расширен: добавлен атрибут model и новый метод honk

### Полиморфизм

**Полиморфизм в объектно-ориентированном программировании (ООП)** — это возможность объектов разных классов использовать один и тот же интерфейс (методы с одинаковым названием), но при этом реализовывать их по-разному. Слово «полиморфизм» происходит из греческого языка и буквально означает «много форм».

###### Пример кода

В Python есть некоторые функции, которые могут принимать аргументы разных типов.

Одна из таких функций — `len()`. Она может принимать различные типы данных. 

```python

print(len("Programiz"))
print(len(["Python", "Java", "C"]))
print(len({"Name": "John", "Address": "Nepal"}))

```
**Вывод:**
```
9
3
2
```

Здесь мы можем увидеть, что различные типы данных, такие как строка, список, кортеж, множество и словарь могут работать с функцией `len()`. Однако, мы можем увидеть, что она возвращает специфичную для каждого типа данных информацию.