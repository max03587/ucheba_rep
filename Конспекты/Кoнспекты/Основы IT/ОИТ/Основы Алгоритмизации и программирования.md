#ОИТ #Алан_Тьюринг #Big_O #Алгоритмы
# Основы Алгоритмизации и программирования

### Управление компьютером при помощи программ: Теоретическая основа и архитектура.

**Компьютер** как универсальная вычислительная машина (по определению [[Алан Тьюринг|Алана Тьюринга]]), представляет собой устройство, способное выполнять произвольные алгоритмы при наличии подходящей *программы.* 

Программа - это формализованная последовательность инструкций, предназначенная для управления ресурсами ЭВМ (в данном случае, компьютера). В научном смысле управление при помощи программ, реализуется через машинную модель **Джона фон Неймана**, где программы и данные хранятся в единой памяти, а процессор последовательно интерпретирует команды. 

С точки зрения архитектуры, программа сначала загружается в оперативную память, затем извлекается для выполнения, декодируется и исполняется процессором. Взаимодействие с программой осуществляется при помощи устройств ввода/вывода.

###### Роль операционной системы (ОС)

ОС выступает как посредник, абстрагируя аппаратные детали, лишь предоставляя интерфейсы ограниченного взаимодействия с ними. В терминах теории систем, ОС реализует виртуализацию ресурсов, позволяя нескольким программам работать параллельно.

###### **Вывод:**

Без программ компьютер остается пассивным устройством, а программы наделяют его интеллектом, через детерминированное выполнение. Т.е., на данный момент, именно пользователь, отталкиваясь от задачи, определят исполнителя и его характеристики.


### Понятие алгоритма: формальное определение и свойства

Алгоритм - это абстрактная логически-математическая конструкция, представляющая собой конечную последовательность строго определенных шагов, приводящих от начального состояния (входных данных) к желаемому результату (выходные данные).
Сам термин происходит от латинской транслитерации имени Персидского математика Мухаммеда аль-Хорезми, жившего в 9 веке. Его труды заложили основу систематического решения уравнений. 

###### Основные свойства алгоритма

1.Детерминированность (Однозначность) - каждый шаг определяет уникальное действие для данного состояния.

2.Массовость (Общность) - алгоритм применим к классу задач, а не к одной конкретной.

3.Результативность (Эффективность) - гарантирует получение корректного результата.

4.Дискретность - возможность разбиение алгоритма на атомарные (примитивные) 
операции.

5.Конечность - любой алгоритм завершается за конечное число шагом.

6.Корректность - результат соответствует ожидаемому и может быть проверен (доказан)

Также алгоритмы поддаются следующему анализу:
- Временная сложность
- Пространственная сложность
- Средний случай

ВС - мера кол-во вычислительных ресурсов (времени), необходимых для выполнения алгоритма в зависимости от входных данных.

ПС - мера объема памяти, необходимого для выполнения входных данных. 

###### Big-O Notation (Нотация большой O)

**Big O** - это термин из области анализа сложности алгоритмов и структур данных в информатике. Он используется для оценки верхней границы (наихудшего случая), временной сложности алгоритма.

Простыми словами **Big O** показывает как будет меняться производительность алгоритма с зависимости от роста входящих данных.

Если мы будем увеличивать количество входящих данных, то у нас может расти количество операций и время за которое выполнится алгоритм. Так же может расти количество памяти используемой данным алгоритмом для обработки входного объема данных. **Big O** будет показывать скорость роста времени исполнения алгоритма.

**Big O** называется так из-за того, что в математике "**O**" используется для обозначения "**order of**" (порядка) и позволяет сравнивать функции роста. Он представляет собой математическую нотацию, которая описывает, как алгоритм будет выполняться в наихудшем случае, исходя из размера входных данных.

### Примеры нотаций Big O

- **O(1):** **Константная сложность**. Время выполнения алгоритма не зависит от размера входных данных. Например, доступ к элементу массива по индексу.
    
- **O(log n)**: **Логарифмическая сложность**. Время выполнения алгоритма растет медленно с увеличением размера входных данных. Например, бинарный поиск в отсортированном массиве.
    
- **O(n)**: **Линейная сложность**. Время выполнения алгоритма пропорционально размеру входных данных. Например, просмотр всех элементов в массиве.
    
- **O(n log n)**: **Линейно-логарифмическая сложность**. Время выполнения алгоритма растет быстрее, чем линейно, но медленнее, чем квадратично. Например, сортировка слиянием (merge sort).
    
- **O(n^2)**: **Квадратичная сложность**. Время выполнения алгоритма зависит от квадрата размера входных данных. Например, сортировка пузырьком (bubble sort).
    
- **O(n^3):** **Кубическая сложность**. Время выполнения алгоритма зависит от размера входных данных в кубе. Например, алгоритмы, которые имеют три вложенных цикла, такие как некоторые методы многомерной обработки данных.
    
- **O(n!):** **Факториальная сложность**. Это самая высокая степень роста времени выполнения алгоритма. Время выполнения алгоритма растет факториально от размера входных данных. Этот тип сложности встречается, например, при переборе всех возможных комбинаций элементов, что делает его чрезвычайно неэффективным для больших значений **n**.

## Константная сложность O(1)

**O(1)** называют константной сложностью.

Оценка временной сложности **O(1)** означает, что алгоритм имеет постоянную сложность.

Под **n** мы будем иметь ввиду размер входящих данных.

В JavaScript чаще всего мы храним набор данных в массивах.

Размер массива, то есть его значение свойства `length` и будет значение **n**.

При константной сложности вне зависимости от размера входных данных (**n**), время выполнения алгоритма остается постоянным и не зависит от объема данных.

Это самый быстрый и эффективный вид временной сложности.

Примеры алгоритмов с оценкой временной сложности **O(1)**:

- Доступ к элементу в массиве по индексу. Например, если у вас есть массив с данными, вы можете мгновенно получить доступ к элементу массива, указав его индекс, независимо от размера массива.
    
- Вставка или удаление элемента в конец списка (очереди) фиксированной длины. В этом случае операция выполняется быстро и не зависит от количества элементов в списке.
    

Оценка временной сложности **O(1)** является идеальной с точки зрения производительности. Однако в реальных задачах она не всегда достижима, и в большинстве случаев оценка временной сложности будет выше.

## Линейная сложность O(n)

**O(n)** называют линейной сложностью.

**Линейный рост** - это понятие, которое описывает зависимость между двумя величинами, при которой одна величина увеличивается пропорционально увеличению другой.

Оценка временной сложности **O(n)** означает, что время выполнения алгоритма растет линейно с увеличением размера входных данных.

```
function findMax(arr) { 
   let max = arr[0]; 
      for (let i = 1; i < arr.length; i++){        
      if (arr[i] > max) {
        max = arr[i];        
               } 
                  }    
               return max;
		               }
```

В этом примере `findMax` ищет максимальное значение в массиве `arr`.

Алгоритм начинает с предположения, что первый элемент массива (`arr[0]`) является максимальным, а затем линейно (то есть по одному элементу) перебирает остальные элементы, сравнивая каждый с текущим максимальным. Сложность этого алгоритма **O(n)**, так как время выполнения растет линейно с увеличением количества элементов в массиве `arr`.

При линейном росте при увеличении размера входных данных вдвое, то время выполнения алгоритма также увеличится примерно вдвое. Если увеличите размер данных в 10 раз, то время выполнения увеличится приблизительно в 10 раз, и так далее.

Линейный рост характерен для алгоритмов, которые выполняют постоянное количество операций для каждого элемента входных данных.

## Логарифмическая сложность O(log n)

**O(log n)** называют логарифмической сложностью.

Оценка временной сложности **O(log n)** означает, что время выполнения алгоритма увеличивается логарифмически с увеличением размера входных данных **(n)**. Другими словами, алгоритм становится медленнее, но не линейно, а медленнее в соответствии с логарифмической функцией.

Пример алгоритма с оценкой временной сложности **O(log n)** - **бинарный поиск**. В этом алгоритме на каждом шаге половина данных отсекается, и поиск продолжается в оставшейся половине. Это означает, что при увеличении размера входных данных вдвое, бинарный поиск требует всего одного дополнительного шага.

Таким образом, алгоритмы с оценкой временной сложности **O(log n)** эффективны и быстры при работе с большими объемами данных, так как их производительность ухудшается медленно с увеличением размера данных.

Бинарный поиск ищет значение в отсортированном массиве, разделяя его пополам на каждой итерации. Поиск начинается с середины массива. Если значение, которое мы ищем, больше среднего элемента, поиск продолжается в правой половине массива. Если оно меньше, то в левой. Таким образом, на каждой итерации мы уменьшаем область поиска примерно в два раза, что обеспечивает логарифмическую сложность **O(log n)**.

## Квадратичная сложностьO(n^2)

**O(n^2**) означает квадратичную сложность алгоритма, где время выполнения растет пропорционально квадрату размера входных данных. Это часто возникает в алгоритмах с вложенными циклами, когда каждый элемент первого списка обрабатывается с каждым элементом второго списка.

## Экспоненциальная сложность O(2^n)

Сложность **O(2^n)** относится к экспоненциальной сложности, где время выполнения алгоритма увеличивается экспоненциально по мере увеличения размера входных данных. Это часто встречается в алгоритмах, которые решают проблемы методом "разделяй и властвуй" или используют рекурсию без оптимизации.

## Факториальная сложность O(n!)

Сложность **O(n!)** относится к факториальной сложности, где время выполнения алгоритма растет пропорционально факториалу размера входных данных. Факториал - это произведение всех положительных целых чисел от **1 до n**.

Такой алгоритм обладает очень высокой вычислительной сложностью и может стать практически неиспользуемым для больших входных данных из-за огромного числа операций, которые необходимо выполнить.

![[Pasted image 20250929113349.jpg]]

###### Классификация по структуре 

 1.Линейные, которые выполняются последовательно
 2.С ветвлением, например, условные конструкции
 3.Циклические, в которых задействованы повторения
 4.Рекурсивные, в которых происходит обращение алгоритма к самому себе
 5.